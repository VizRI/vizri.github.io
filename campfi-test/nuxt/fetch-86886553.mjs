import{j as k,k as g,l as x,m as C,p as b,q as O,s as P,u as E,v as z}from"./entry-21f8eecd.mjs";const F=s=>k(s)?s:g(s),R=()=>null;function B(...s){var y,p,h,m,v,D,_;const f=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(f);let[a,i,t={}]=s;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");t.server=(y=t.server)!=null?y:!0,t.default=(p=t.default)!=null?p:R,t.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),t.lazy=(m=(h=t.lazy)!=null?h:t.defer)!=null?m:!1,t.initialCache=(v=t.initialCache)!=null?v:!0;const e=x(),c=P();if(c&&!c._nuxtOnBeforeMountCbs){const r=c._nuxtOnBeforeMountCbs=[];c&&(C(()=>{r.forEach(o=>{o()}),r.splice(0,r.length)}),b(()=>r.splice(0,r.length)))}const u=()=>t.initialCache&&e.payload.data[a]!==void 0,n={data:F((D=e.payload.data[a])!=null?D:t.default()),pending:g(!u()),error:g((_=e.payload._errors[a])!=null?_:null)};n.refresh=(r={})=>e._asyncDataPromises[a]?e._asyncDataPromises[a]:r._initial&&u()?e.payload.data[a]:(n.pending.value=!0,e._asyncDataPromises[a]=Promise.resolve(i(e)).then(o=>{t.transform&&(o=t.transform(o)),t.pick&&(o=M(o,t.pick)),n.data.value=o,n.error.value=null}).catch(o=>{n.error.value=o,n.data.value=E(t.default())}).finally(()=>{n.pending.value=!1,e.payload.data[a]=n.data.value,n.error.value&&(e.payload._errors[a]=!0),delete e._asyncDataPromises[a]}),e._asyncDataPromises[a]);const l=()=>n.refresh({_initial:!0}),w=t.server!==!1&&e.payload.serverRendered;{w&&e.isHydrating&&a in e.payload.data?n.pending.value=!1:c&&e.payload.serverRendered&&(e.isHydrating||t.lazy)?c._nuxtOnBeforeMountCbs.push(l):l(),t.watch&&O(t.watch,()=>n.refresh());const r=e.hook("app:data:refresh",o=>{if(!o||o.includes(a))return n.refresh()});c&&b(r)}const d=Promise.resolve(e._asyncDataPromises[a]).then(()=>n);return Object.assign(d,n),d}function M(s,f){const a={};for(const i of f)a[i]=s[i];return a}function A(s,f,a){const[i,t]=typeof f=="string"?[{},f]:[f,a],e=i.key||t;if(!e||typeof e!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+e);if(!s)throw new Error("[nuxt] [useFetch] request is missing.");const c="$f"+e,u=z(()=>{let r=s;return typeof r=="function"&&(r=r()),k(r)?r.value:r}),{server:n,lazy:l,default:w,transform:d,pick:y,watch:p,initialCache:h,...m}=i,v={...m,cache:typeof i.cache=="boolean"?void 0:i.cache},D={server:n,lazy:l,default:w,transform:d,pick:y,initialCache:h,watch:[u,...p||[]]};return B(c,()=>$fetch(u.value,v),D,"$Y1nhoWDLED")}export{A as u};
